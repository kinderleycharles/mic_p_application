/*
 * Lab4 Part A
 * Name:		Kinderley Charles
 * Section:		6957
 * TA:			Khaled Hassan
 * Description:	This program read the key pressed in a keypad and output an LED pattern
 *				representing the key pressed
 */ 

 .include "ATxmega128A1Udef.inc"

 .SET IN_PORT = 0x8000						; Base address
 .EQU STACK_ADDR = 0x3FFF					; Address to initialize Stack


 .ORG 0x0000								; Beginning of program
	RJMP MAIN								; Leave space for interrupt vectors

.ORG 0x100
KEYS:		.DB 0x01, 0x04, 0x07, 0x0E, 0x02, 0x05, 0x08, 0x00, 0x03, 0x06, 0x09, 0x0F, 0x0A, 0x0B, 0x0C, 0x0D, 0xFF

.ORG 0x0200
MAIN:
	// INITIALIZE STACK POINTER
	LDI R16, LOW(STACK_ADDR)
	STS CPU_SPL, R16
	LDI R16, HIGH(STACK_ADDR)
	STS CPU_SPH, R16

	// PORT CONFIGURATION FOR KEYPAD
	LDI R16, 0xF0							; Setting MOST sig nibble in port E as input
	STS PORTE_DIRCLR, R16					; PORTE[7:4] set as input
	LDI R16, 0x0F							; Setting LEAST sig nibble in port E as output
	STS PORTE_DIRSET, R16					; PORTE[3:0] set as output

	LDI R16, 0b00011000						; Pull-up resistor configuration
	STS PORTE_PIN7CTRL, R16					; Add pull-up resistor to pin 7
	STS PORTE_PIN6CTRL, R16					; Add pull-up resistor to pin 6
	STS PORTE_PIN5CTRL, R16					; Add pull-up resistor to pin 5
	STS PORTE_PIN4CTRL, R16					; Add pull-up resistor to pin 4

	// EBI PORT CONFIGURATION
	LDI R16, 0b10011						; Configure the PORTH bits 4, 2 and 1 as outputs. 
	STS PORTH_DIRSET, R16 					; These are the CS0(L), RE(L) and WE(L) outputs.

	LDI R16, 0b10011						; Since WE(L), RE(L), and CS0(L) are active low signals, we must set  
	STS PORTH_OUTSET, R16					; the default output to 1 = H = false. ALE defaults to 0 = L = false
	
	LDI R16, 0xFF							; Set all PORTK pins (A15-A0) to be outputs. As requried	
	STS PORTK_DIRSET, R16					; in the data sheet. See 8331, sec 27.9.

	LDI R16, 0xFF							; Set all PORTJ pins (D7-D0) to be outputs. As requried 
	STS PORTJ_DIRSET, R16					; in the data sheet. See 8331, sec 27.9.
		
	LDI R16, 0x01							; Store 0x01 in EBI_CTRL register to select 3 port EBI(H,J,K) 
	STS EBI_CTRL, R16						; mode and SRAM ALE1 mode.

	// CHIP SELECT INITIALIZATION
	LDI ZH, high(EBI_CS0_BASEADDR)
	LDI ZL, low(EBI_CS0_BASEADDR)
	LDI R16, byte2(IN_PORT)				
	ST Z+, R16	
	LDI R16, byte3(IN_PORT)
	ST Z, R16

	LDI R16, 0x15							; Set to 8K chip select space and turn on SRAM mode, 0x37 E000 - 0x37 FFFF
	STS EBI_CS0_CTRLA, R16					

	LDI R16, byte3(IN_PORT)					; initalize a pointer to point to the base address of the IN_PORT
	STS CPU_RAMPX, r16						; use the CPU_RAMPX register to set the third byte of the pointer
	LDI XH, high(IN_PORT)					; set the middle (XH) and low (XL) bytes of the pointer as usual
	LDI XL, low(IN_PORT)

LOOP:
	RCALL SCAN_KEYPAD
	ST X, R16								; Output key pressed to LED
	RJMP LOOP




/*******************************************************************************************************
                                              SUBROUTINES
 *******************************************************************************************************
 * Name:     SCAN_KEYPAD
 * Purpose:  Scan a keypad to figure which key is pressed
 * Inputs:   None
 * Outputs:  R16
 * Affected: R17, R18, R19, R20, R21 and Z
 *******************************************************************************************************/
SCAN_KEYPAD:
	
	// Save registers content
	PUSH ZL										; Z register
	PUSH ZH
	PUSH R17
	PUSH R18
	PUSH R19
	PUSH R20
	PUSH R21

	LDI R17, 4									; i = 4
	LDI R19, 0xF7								; Start testing with 0111
	CLR R16
LOOPI:
	ORI R19, 0xF0								; Ensure that most sig fig nibble is always F

	// SET Z AS POSSIBLE COLUMN WHERE KEY IS PRESSED
	CPI R19, 0xF7
	BRNE T1
	LDI ZL, LOW(0x100 << 1)						; Z -> KEYS[] --> 1,4,7,*
	LDI ZH, HIGH(0x100 << 1)
T1:
	CPI R19, 0xFB
	BRNE T2
	LDI ZL, LOW(0X102 << 1)						; Z -> KEYS[] --> 2,5,8,0
	LDI ZH, HIGH(0X102 << 1)

T2:
	CPI R19, 0xFD
	BRNE T3
	LDI ZL, LOW(0X104 << 1)						; Z -> KEYS[] --> 3,6,9,#
	LDI ZH, HIGH(0X104 << 1)

T3:
	CPI R19, 0xFE
	BRNE T4
	LDI ZL, LOW(0X106 << 1)						; Z -> KEYS[] --> A,B,C,D
	LDI ZH, HIGH(0X106 << 1)

T4:
	LDI R18, 4									; y = 4
	LDI R20, 0xF7
	STS PORTE_OUT, R19							; Output a value: KEYPAD_TEST[]
	NOP
	NOP
	LDS R21, PORTE_IN							; Read input generated by outputted value
	SWAP R21									; Make input read the lowest nibble
												; 1101 0000 change to 0000 1101
	ORI R21, 0xF0								; Set upper nibble to 0xF to make CP ins easier

LOOPY:
	ORI R20, 0xF0								; Ensure that most sig nibble is always F
	LPM R16, Z+									; R16 is current answer
	CP R21, R20
	BREQ KEY_FOUND
	ROR R20
	DEC R18										; y--
	BRNE LOOPY									; No, Keep looping
	
	ROR R19
	DEC R17
	BRNE LOOPI									; No, Keep looping

	LDI R16, 0xFF								; No key pressed, R16 = 0xFF

KEY_FOUND:	
	// Retore registers content
	POP R21
	POP R20
	POP R19
	POP R18
	POP R17
	POP ZH										; Z register
	POP ZL
	
	RET											; Return from subroutine